# 维度生成
## 一切的开始——Level
一切的一切都要从`MinecreaftServer#createLevels`开始说起。我们看到这个方法很长，但是我们添加新维度的关键在于:
```Java
   protected void createLevels(ChunkProgressListener p_129816_) {
       //······
      for(Entry<ResourceKey<LevelStem>, LevelStem> entry : registry.entrySet()) {
         ResourceKey<LevelStem> resourcekey = entry.getKey();
         if (resourcekey != LevelStem.OVERWORLD) {
            ResourceKey<Level> resourcekey1 = ResourceKey.create(Registry.DIMENSION_REGISTRY, resourcekey.location());
            Holder<DimensionType> holder1 = entry.getValue().typeHolder();
            ChunkGenerator chunkgenerator1 = entry.getValue().generator();
            DerivedLevelData derivedleveldata = new DerivedLevelData(this.worldData, serverleveldata);
            ServerLevel serverlevel1 = new ServerLevel(this, this.executor, this.storageSource, derivedleveldata, resourcekey1, holder1, p_129816_, chunkgenerator1, flag, j, ImmutableList.of(), false);
            worldborder.addListener(new BorderChangeListener.DelegateBorderChangeListener(serverlevel1.getWorldBorder()));
            this.levels.put(resourcekey1, serverlevel1);
            net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.WorldEvent.Load(levels.get(resourcekey)));
         }
      }
      //······
   }
```
我们可以看到`ServerLevel`是根据`LevelStem`自动生成的，也就是说我们只需要实例化我们自己的`LevelStem`，并将其注册，我们就实现了我们的最终目的——添加维度。
## 统领万物者——LevelStem
让我们将目光投向`LevelStem`类,我们发现`LevelStem`的构造函数有两个,我们选择Forge添加的那个:
```Java
   public LevelStem(Holder<DimensionType> p_204519_, ChunkGenerator p_204520_, boolean useServerSeed) { // forge: allow dimension jsons to specify that they should use the server seed instead of the fixed seed field
      this.useServerSeed = useServerSeed; // forge
      this.type = p_204519_;
      this.generator = p_204520_;
   }
```
我们发现这构造函数接收一个`Holder<DimensionType>`和`ChunkGenerator`,这个`Holder`可以简单理解为类似指针的东西，指向指定的元素(在Datagen里面可以认为是生成出来的对应文件)。
### 神说要有光，于是便有了光——DimensionType
让我们走向`DimensionType`类,但是我们会发现构造函数是私有的，不过我们可以找到一个`DimensionType#create`方法,这是因为他的设计模式导致的，这里就不展开说了。该方法如下:
```Java
   public static DimensionType create(OptionalLong pFixedTime, boolean pHasSkylight, boolean pHasCeiling, boolean pUltraWarm, boolean pNatural, double pCoordinateScale, boolean pCreateDragonFight, boolean pPiglinSafe, boolean pBedWorks, boolean pRespawnAnchorWorks, boolean pHasRaids, int pMinY, int pHeight, int pLogicalHeight, TagKey<Block> pInfiniburn, ResourceLocation pEffectsLocation, float pAmbientLight) {
      DimensionType dimensiontype = new DimensionType(pFixedTime, pHasSkylight, pHasCeiling, pUltraWarm, pNatural, pCoordinateScale, pCreateDragonFight, pPiglinSafe, pBedWorks, pRespawnAnchorWorks, pHasRaids, pMinY, pHeight, pLogicalHeight, pInfiniburn, pEffectsLocation, pAmbientLight);
      guardY(dimensiontype).error().ifPresent((p_156692_) -> {
         throw new IllegalStateException(p_156692_.message());
      });
      return dimensiontype;
   }
```
参数详解:<br/>

 |         参数          |                                                                                                                                                        解释                                                                                                                                                        |
 | :-------------------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
 |     `pFixedTime`      |                                                                                                                 表示这个维度所固定的时间，如果不想固定时间，可以传一个`OptionalLong.empty()`进去。                                                                                                                 |
 |    `pHasSkylight`     |                                                                                                                                            字面意思，是否拥有天空光照。                                                                                                                                            |
 |     `pHasCeiling`     |                                                                                                                                     是否拥有天花板，也就是地狱最上面那层东西。                                                                                                                                     |
 |     `pUltraWarm`      |                                                                                                                  维度是否表现得类似于下界水会蒸发，湿海绵会干。这也会使得熔岩流动更快、扩散更远。                                                                                                                  |
 |      `pNatural`       |                                                                                                                     当为 false 时，指南针会随机转动；当为 true 时，下界传送门会生成僵尸猪灵。                                                                                                                      |
 |  `pCoordinateScale`   |                                                                                                                                               当前维度坐标放缩倍率。                                                                                                                                               |
 | `pCreateDragonFight`  |                                                                                                                                                 是否会生成末影龙。                                                                                                                                                 |
 |     `pPiglinSafe`     |                                                                                                                                            猪灵和疣猪兽是否不会僵尸化。                                                                                                                                            |
 |      `pBedWorks`      |                                                                                                                                                   床是否会爆炸。                                                                                                                                                   |
 | `pRespawnAnchorWorks` |                                                                                                                                              玩家是否可以使用重生锚。                                                                                                                                              |
 |      `pHasRaids`      |                                                                                                                                        带有不祥之兆的玩家是否可以触发袭击。                                                                                                                                        |
 |        `pMinY`        |                                                                                                                                          此维度中可以存在方块的最低高度。                                                                                                                                          |
 |       `pHeight`       |                                                                                                   不超过4096的16的倍数, 此维度中可以存在方块的总高度。维度中可以存在方块的最大高度的值等于min_y与height值之和。                                                                                                    |
 |   `pLogicalHeight`    |                                                                                                                                     玩家使用紫颂果或传送门可以到达的最大高度。                                                                                                                                     |
 |     `pInfiniburn`     |                                                                                                 "方块标签命名空间ID" 决定该维度中火可以在什么方块上永久燃烧。正常情况下传一个`BlockTags.INFINIBURN_OVERWORLD`进去                                                                                                  |
 |  `pEffectsLocation`   | 用于确定该维度的天空效果。设为`DimensionType.OVERWORLD_EFFECTS`会使维度的天空中出现云、太阳、星星和月亮；设为`DimensionType.NETHER_EFFECTS`会使维度中有浓厚的迷雾阻挡视野，效果与下界类似；设为`DimensionType.END_EFFECTS`会使维度拥有类似于末地的，黑暗的、斑驳的天空，并无视各生物群系自带的天空颜色与迷雾颜色。 |
 |    `pAmbientLight`    |                                                                                                                                       0~1 之间的数值, 该维度拥有多少环境光。                                                                                                                                       |

### 世界之基——ChunkGenerator
接下来让我们查看`ChunkGenerator`类,我们发现这个类是一个抽象类，总共有三个实现类。分别为:<br/>
`DebugLevelSource`会将所有方块及其`BlockState`全部生成在一个平面上。<br/>
`NoiseBasedChunkGenerator`基于噪声的区块生成器。<br/>
`FlatLevelSource`超平坦生成器。<br/>
我们选择实例化`NoiseBasedChunkGenerator`类。我们可以使用的该类的构造方法如下:
```Java
   public NoiseBasedChunkGenerator(Registry<StructureSet> p_209106_, Registry<NormalNoise.NoiseParameters> p_209107_, BiomeSource p_209108_, long p_209109_, Holder<NoiseGeneratorSettings> p_209110_) {
      this(p_209106_, p_209107_, p_209108_, p_209108_, p_209109_, p_209110_);
   }
```
构造方法接收：<br/>
 两个`Registry`对象，前者用于生成该维度的结构（比如堡垒、村庄等），后者是噪声参数（就是一个包装了一层的数据）。我们可以选择直接传`RegistryAccess.BUILTIN.get().registryOrThrow(Registry.STRUCTURE_SET_REGISTRY)`和`RegistryAccess.BUILTIN.get().registryOrThrow(Registry.NOISE_REGISTRY)`进去。<br/> 
 `BiomeSource`是一个抽象类，有四个实现类`FixedBiomeSource`、`MultiNoiseBiomeSource`、`CheckerboardColumnBiomeSource`、`TheEndBiomeSource`。<br/>
`p_209109_`实际上是一个种子。<br/>
`Holder<NoiseGeneratorSettings>`用于获取噪声设置。<br/>
#### 我想把这玩意染成绿的.jpg——BiomeSource
前面我们说道，`BiomeSource`是一个抽象类，有四个实现。每个实现的功能如下:

|               类                |           功能           |
| :-----------------------------: | :----------------------: |
|       `FixedBiomeSource`        | 整个维度都将只有一种群系 |
|     `MultiNoiseBiomeSource`     |  基于多种噪声的群系生成  |
| `CheckerboardColumnBiomeSource` |   棋盘格样式的群系生成   |
|       `TheEndBiomeSource`       |    末地使用的群系生成    |

这里不是重点，所以我们选择使用`FixedBiomeSource`,其构造方法如下:
```Java
   public FixedBiomeSource(Holder<Biome> p_204257_) {
      super(ImmutableList.of(p_204257_));
      this.biome = p_204257_;
   }
```
所以我们只需要将我们的`Holder<Biome>`传进去即可。
#### 万物核心——NoiseGeneratorSettings
我们可以看到这个类是一个[`record`](https://blog.csdn.net/sayWhat_sayHello/article/details/121902216)类，其构造函数接收:

|          参数           |                      详解                      |
| :---------------------: | :--------------------------------------------: |
|     `noiseSettings`     |                    噪声设置                    |
|     `defaultBlock`      |             用于填充世界的默认方块             |
|     `defaultFluid`      |             用于填充世界的默认流体             |
|      `noiseRouter`      |         字面意思,只有噪声的噪声路由器          |
|      `surfaceRule`      | 地形的表面规则配置。取代了旧的表面构建器系统。 |
|       `seaLevel`        |                   海平面高度                   |
| `disableMobGeneration`  |       是否禁止被动型生物随地形一起生成。       |
|    `aquifersEnabled`    |                 是否生成含水层                 |
|    `oreVeinsEnabled`    |                  是否生成矿脉                  |
| `useLegacyRandomSource` | 是否使用1.19之前的旧的随机数生成器来生成世界。 |

###### 噪声设置——NoiseSettings