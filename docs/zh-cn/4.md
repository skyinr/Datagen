# 维度生成
## 一切的开始——Level
一切的一切都要从`MinecreaftServer#createLevels`开始说起。我们看到这个方法很长，但是我们添加新维度的关键在于:
```Java
   protected void createLevels(ChunkProgressListener p_129816_) {
       //······
      for(Entry<ResourceKey<LevelStem>, LevelStem> entry : registry.entrySet()) {
         ResourceKey<LevelStem> resourcekey = entry.getKey();
         if (resourcekey != LevelStem.OVERWORLD) {
            ResourceKey<Level> resourcekey1 = ResourceKey.create(Registry.DIMENSION_REGISTRY, resourcekey.location());
            Holder<DimensionType> holder1 = entry.getValue().typeHolder();
            ChunkGenerator chunkgenerator1 = entry.getValue().generator();
            DerivedLevelData derivedleveldata = new DerivedLevelData(this.worldData, serverleveldata);
            ServerLevel serverlevel1 = new ServerLevel(this, this.executor, this.storageSource, derivedleveldata, resourcekey1, holder1, p_129816_, chunkgenerator1, flag, j, ImmutableList.of(), false);
            worldborder.addListener(new BorderChangeListener.DelegateBorderChangeListener(serverlevel1.getWorldBorder()));
            this.levels.put(resourcekey1, serverlevel1);
            net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.WorldEvent.Load(levels.get(resourcekey)));
         }
      }
      //······
   }
```
我们可以看到ServerLevel是根据LevelStem自动生成的，也就是说我们只需要实例化我们自己的LevelStem，并将其注册，我们就实现了我们的最终目的——添加维度。
## 统领万物者——LevelStem
让我们将目光投向`LevelStem`类,我们发现`LevelStem`的构造函数有两个,我们选择Forge添加的那个:
```Java
   public LevelStem(Holder<DimensionType> p_204519_, ChunkGenerator p_204520_, boolean useServerSeed) { // forge: allow dimension jsons to specify that they should use the server seed instead of the fixed seed field
      this.useServerSeed = useServerSeed; // forge
      this.type = p_204519_;
      this.generator = p_204520_;
   }
```
我们发现这构造函数接收一个Holder和ChunkGenerator。